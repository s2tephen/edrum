<% content_for :title, "Practice" %>

<button class="play-btn" id="learn-play-btn">PLAY</button>

<canvas id="sheet" width="1400" height="720">
</canvas>

<div class="drum-name" id="drum-name0"></div>
<div class="drum-name" id="drum-name1"></div>
<div class="drum-name" id="drum-name2"></div>

<%= javascript_include_tag "practice" %>

<%= javascript_tag "var sequence = #{@sequence.to_json}" %>
<%= javascript_tag "var seqNotes = #{@sequence.notes.to_json}" %>
<%= javascript_tag do %>
  var sequence = <%= raw @sequence.to_json %>;
  var bars = <%= raw @sequence.vexflow.to_json %>
<% end %>

<script>

  $("#sheet").attr("height", 360 * Math.floor(sequence.bars / 2 + 0.5));

  var canvas = $("#sheet")[0];
  var renderer = new Vex.Flow.Renderer(canvas, Vex.Flow.Renderer.Backends.CANVAS);

  var ctx = renderer.getContext();
  ctx.scale(4, 4);

  var staveX = 5;
  var staveY = -10;
  var staveWidth = 170;
  var staveHeight = 90;

  var mapping = ["a/5","g/5","f/5","e/5","d/5","c/5","a/4","f/4"];

  for (i = 0; i < bars.length; i++) { // bars
    var stave;

    if (i % 2 == 0) {
      stave = new Vex.Flow.Stave(staveX, staveY, staveWidth);
      if (i == 0) {
        stave.addClef("percussion").addTimeSignature(sequence.meter_top + "/" + sequence.meter_bottom);
      }
    }
    else {
      stave = new Vex.Flow.Stave(staveX + staveWidth, staveY, staveWidth);
      staveY += staveHeight;
    }
    stave.setContext(ctx).draw();

    var voices = [];
    for (j = 0; j < bars[i].length; j++) { // voices
      var notes = [];
      var noteBuffer = []; // used to separate quarter notes
      for (k = 0; k < bars[i][j].length; k++) { // note groups
        // separate into beam/no beam
        if (noteBuffer.length == 0) {
          noteBuffer.push(bars[i][j][k][0].duration < 1) // true if beam, false otherwise
        }
        else if (bars[i][j][k][0].duration < 1 != noteBuffer[0] || sequence.meter_bottom*noteBuffer.slice(1).reduce(function(p, c, i, a) { return p + 1/c.duration }, 0) == 1)  {
          notes.push(noteBuffer);
          noteBuffer = [bars[i][j][k][0].duration < 1];
        }

        // construct stave note
        if (bars[i][j][k].length == 1) { // single note
          var currNote = bars[i][j][k][0];
          if (currNote.drum == -1) { // rest
            if (currNote.duration * 100 % 3 == 0) {
              noteBuffer.push(new Vex.Flow.StaveNote({ keys: ["b/4"], duration: vexDuration(currNote.duration/3) + "r" }));
              noteBuffer.push(new Vex.Flow.StaveNote({ keys: ["b/4"], duration: vexDuration(2*currNote.duration/3) + "r" }));
            }
            else {
              noteBuffer.push(new Vex.Flow.StaveNote({ keys: ["b/4"], duration: vexDuration(currNote.duration) + "r" }));
            }
          }
          else { // note
            noteBuffer.push(new Vex.Flow.StaveNote({ keys: [mapping[currNote.drum]], duration: vexDuration(currNote.duration) }));
          }
        }
        else { // chord
          var keys = [];
          var currNotes = bars[i][j][k];
          for (l = 0; l < currNotes.length; l++) {
            keys.push(mapping[currNotes[l].drum]);
          }
          noteBuffer.push(new Vex.Flow.StaveNote({ keys: keys, duration: vexDuration(currNotes[0].duration) }));
        }
      }
      notes.push(noteBuffer);
      voices.push(notes);
    }

    // draw the bar
    var beams = [];

    for (m = 0; m < voices.length; m++) {
      for (n = 0; n < voices[m].length; n++) {
        if (voices[m][n].shift()) { // beam me up, scotty
          beams.push(new Vex.Flow.Beam(voices[m][n]));
        }
      }
      voices[m] = [].concat.apply([], voices[m]); // flatten bar
      Vex.Flow.Formatter.FormatAndDraw(ctx, stave, voices[m]);
    }

    for (n = 0; n < beams.length; n++) {
      beams[n].setContext(ctx).draw();
    }
  }

  function vexDuration(duration) {
    return (sequence.meter_bottom / duration) + "";
  }
</script>